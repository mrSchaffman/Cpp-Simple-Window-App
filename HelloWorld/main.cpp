/*
	Copyright (C) 2022  Barth.Feudong
	Author can be contacted here: <https://github.com/mrSchaffman/Cpp-Simple-Window-App>

	This file is part of the HelloWorld project.

	HelloWorld is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	HelloWorld is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.

*/

#ifndef UNICODE
#define UNICODE
#endif // UNICODE

#include<Windows.h>

// The Callback Signature, The Procedure for This "hello World" Window.
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
		// Additional data for the message is contained in the lParam and wParam parameters. 
		// Both parameters are integer values the size of a pointer width (32 bits or 64 bits).
	switch (uMessage)
	{
	case WM_DESTROY:
		PostQuitMessage(0);				// puts a WM_QUIT message on the message queue.
										// WM_QUIT is a special message : It causes GetMessage to return 0, 
										// signaling the end of the message loop.Here is the revised message loop.
		return 0;
	case WM_PAINT:
	{
		PAINTSTRUCT paintStructure;

		// paint the Window
		HDC hdc = BeginPaint(hwnd, &paintStructure);

		FillRect(hdc, &paintStructure.rcPaint, (HBRUSH)(COLOR_WINDOW + 1));
		EndPaint(hwnd, &paintStructure);
	}
	return 0;
	//case WM_SIZE:
	//{
	//	int width = LOWORD(lParam);  // Macro to get the low-order word.
	//	int height = HIWORD(lParam); // Macro to get the high-order word.

	//	// Respond to the message:
	//	OnSize(hwnd, (UINT)wParam, width, height);
	//}
	//break;
	}

	// use message default handler behavior for other messages
	return DefWindowProc(hwnd, uMessage, wParam, lParam);
}
void OnSize(HWND hwnd, UINT flag, int width, int height)
{
	// Handle resizing
}
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPInstance, PWSTR pCmdLine, int nCmdShow)
{

	// Create, set a Window Class associate with my Window and register it with the opereratin System

	WNDCLASS winClass = {};		// Commond data related to a window
	const wchar_t theClassName[] = L"Hello World Window Class";

	winClass.lpfnWndProc = WindowProc;		// where the Behavior of this window is defined.
	winClass.hInstance = hInstance;			// the handle of this instance, generated by the operatin system
	winClass.lpszClassName = theClassName;	// a string to identify the window in the Current process

	RegisterClass(&winClass);

	// Create the Window
	// this function return a "handle" to the Created window, used as target to messages coming from the operating system
	HWND hwnd = CreateWindowEx(
		0,						// optional behavior of the window like the transparency
		theClassName,			// the name used to identify this window in the current process
		L"Hello World",			// The Title 
		WS_OVERLAPPEDWINDOW,	// The Style of the Window
		CW_USEDEFAULT,	// Width
		CW_USEDEFAULT,	// High
		CW_USEDEFAULT,	// position x
		CW_USEDEFAULT,	// Position y
		NULL,			// This Window has no parent.
		NULL,			// no menu bar available yet
		hInstance,
		NULL
	);

	// chech if the Window was create succefully
	if (hwnd == NULL)
		return 0;
	// show the Window.
	ShowWindow(hwnd, nCmdShow);

	// enter the message loop: The application needs a loop to retrieve the messages and dispatch them to the correct windows.
	MSG message = {};
	while (GetMessage(&message,NULL,0,0)>0)		// while receiving the messages from the operating system and the user
	{											// The operating system communicates with my application window by passing 
												// messages(numeric code that designates a particular event.) to it.
												// the > 0 is because of the postQuitMessage(0)  
		
		// exemple of message: #define WM_LBUTTONDOWN    0x0201

		TranslateMessage(&message);				// translates keystrokes (key down, key up) into characters.(mose click, keyboard click...)
		DispatchMessage(&message);				// tells the operating system to call the window procedure of the window that is the target of the message.
												// In other words, the operating system looks up the window handle in its table of windows, 
												// finds the function pointer associated with the window, and invokes the function.




	}


	/*  
		Each Thread has a queue of messages for windows created in it.
		so just call the GetMessage() to retrieve the message from that internal Queue
		each message are generate for a particular
		the MSG structure contains information about the message,including the target window and the message code

		For example, suppose that the user presses the left mouse button. This causes a chain of events:

		1 The operating system puts a WM_LBUTTONDOWN message on the message queue.
		2 My program calls the GetMessage function.
		3 GetMessage pulls the WM_LBUTTONDOWN message from the queue and fills in the MSG structure.
		4 My program calls the TranslateMessage and DispatchMessage functions.
		5 Inside DispatchMessage, the operating system calls My window procedure. (here WindowProc)
		6 My window procedure can either respond to the message or ignore it.	(in the Switch statements)


	*/
	return 0;
}
